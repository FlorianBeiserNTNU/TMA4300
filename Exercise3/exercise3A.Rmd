---
title: "exercise3"
author: "Elsie Backen Tandberg, Maja Mathiassen, Florian Beiser"
date: "23.04.2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Problem A: Comparing AR(2) parameter estimators using resampling of residuals

Given a non-Gaussian time-series $(x_t)_{t=1}^T$ of length $T=100$, an AR(2) model is fitted to the data via least square and least absolute residuals, respectively, yielding two estimated parameters $\beta_1,\beta_2$ each. The respective residuals are recentered. (Note that there are no residuals for the first 2 time points.)

```{r 3Asources}
# The code requires that the extra files are downloaded from the course webpage and stored in the same folder as this Rmd
source("probAhelp.R")
source("probAdata.R")

# Observed timeseries data
x = data3A$x

# Parameter estimates via LS and LA
betas = ARp.beta.est(x, 2)
beta_LS = betas$LS
beta_LA = betas$LA

# Re-centered residuals for LS and LA
e_LS = ARp.resid(x, beta_LS)
e_LA = ARp.resid(x, beta_LA)

```

In order to compare both parameter estimators, the residual resampling bootstrap method is employed. Thereby, the variance and bias of both estimators is estimated. 

```{r 3Abootstrap}
set.seed(2021)
# Input
B = 1500 # number of bootstrap samples
T = 100  # length of time series
p = 2

# Bookkeeping
bootstrap_betas_LS = matrix(0, ncol=p, nrow=B)
bootstrap_betas_LA = matrix(0, ncol=p, nrow=B)

bootstrap_es_LS = matrix(0, nrow=B, ncol=T-p)
bootstrap_es_LA = matrix(0, nrow=B, ncol=T-p)

# Bootstrapping for LS and LA in one (using same realisations)
for (b in 1:B){
  # Construct random but consecutive inital values
  idx0 = sample(T-p+1, 1)
  x0 = x[idx0:(idx0+p-1)]
  # Resample residuals
  idxs = sample(T-p, replace=TRUE)
  e_LS_b = e_LS[idxs]
  e_LA_b = e_LA[idxs]
  # pseudo response
  x_LS_b = ARp.filter(x0, beta_LS, e_LS_b)
  x_LA_b = ARp.filter(x0, beta_LA, e_LA_b)
  # bootstrap estimate
  beta_LS_b = ARp.beta.est(x_LS_b, p)$LS
  beta_LA_b = ARp.beta.est(x_LA_b, p)$LA
  # Storing beta estimate
  bootstrap_betas_LS[b,] = beta_LS_b
  bootstrap_betas_LA[b,] = beta_LA_b
  # Storing residuals for part 2
  bootstrap_es_LS[b,] = ARp.resid(x, beta_LS_b)
  bootstrap_es_LA[b,] = ARp.resid(x, beta_LA_b)
}

# Estimate for variances
var_LS = var(bootstrap_betas_LS)
print(paste("The variance for beta_1 in the LS estimator is ", var_LS[1,1]))
print(paste("The variance for beta_2 in the LS estimator is ", var_LS[2,2]))

var_LA = var(bootstrap_betas_LA)
print(paste("The variance for beta_1 in the LA estimator is ", var_LA[1,1]))
print(paste("The variance for beta_2 in the LA estimator is ", var_LA[2,2]))

# Estimate for bias
# NOTE: This assumes beta_LX as the true value but should be clarified!!!
bias_LS = colMeans(bootstrap_betas_LS) - beta_LS
print(paste("The bias for beta_1 in the LS estimator is ", bias_LS[1]))
print(paste("The bias for beta_2 in the LS estimator is ", bias_LS[2]))

bias_LA = colMeans(bootstrap_betas_LA) - beta_LA
print(paste("The bias for beta_1 in the LA estimator is ", bias_LA[1]))
print(paste("The bias for beta_2 in the LA estimator is ", bias_LA[2]))
```

```{r 3B}
# Bookkeeping
x101_LS = matrix(0, nrow=B)
x101_LA = matrix(0, nrow=B)

# Predicting x_101 for each bootstrap sample:
# x101 = b1*x100 + b2*x99 + e101
# where for b the estimates from part 1 are used
# and e101 is resampled from its empirical distribution
for (b in 1:B){
  x101_LS[b] = bootstrap_betas_LS[b,1]*x[100] + bootstrap_betas_LS[b,2]*x[99] + sample(bootstrap_es_LS[b,],1)
  x101_LA[b] = bootstrap_betas_LA[b,1]*x[100] + bootstrap_betas_LA[b,2]*x[99] + sample(bootstrap_es_LA[b,],1)
}

pred_interval_LS = quantile(x101_LS, probs=c(0.025,0.975))
pred_interval_LA = quantile(x101_LA, probs=c(0.025,0.975))

print(paste("The 95% prediction interval for LS is [",pred_interval_LS[1],",",pred_interval_LS[2],"]"))
print(paste("The 95% prediction interval for LA is [",pred_interval_LA[1],",",pred_interval_LA[2],"]"))
```